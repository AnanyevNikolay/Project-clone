MIS

Этот раздел для описания и концентрации знаний по всем технологиям, еспользуемым на проекте.
Если вы столкнулись с проблемой и нашли решение, поделитесь кратко технологией и хорошими ресурсами.
Не стесняйтесь делиться информацией и делайте добро.

ВАЖНО!
Если вы модифицировали логику или привнесли функционал,
или нашли дополнительные полезные ресурсы, то
обязательно допишите здесь полезную информацию для всех.


HQL

https://java-online.ru/hibernate-hql.xhtml


Swagger

Это фреймворк для спецификации RESTful API. С его помощью можно удобно отправлять запросы на сервер.
Web интерфейс Swagger доступен после старта проекта и аутентификации под определенным юзером
по адресу: http://localhost:8080/swagger-ui/index.html#/ (значение порта 8080 может быть настроено в
application.properties: server.port=)
Информация по SWAGGER - https://habr.com/ru/post/434798/
Настройка в классе SwaggerConfig.
Кратко по работе со Swagger:
После запуска проекта перейдя по адресу: http://localhost:8080/swagger-ui/index.html загрузится
веб интерфейс Swagger. Нам будет доступен контроллер для аутентификации auth-controller
с помощью которого мы можем отправить запрос типа LoginRequest, содержащий два строковых поля:
email и password на сервер (нажать try it out -> вместо string подставить значения -> execute).
При успешной аутентификации получаем ответ типа JwtResponse содержащий сгенерированный токен
(начинается на Bearer), id, email, roles. Для его добавления в header при каждом последующем
запросе нужно скопировать его значение без кавычек, нажать Authorize (кнопка с замочком) ->
вставить значение в поле value -> Authorize (замочек поменяет значение на закрытый).
Для тестирования работы методов контроллера выбираем нужный -> try it out -> вводим необходимые
данные -> execute.

Unit testing

https://habr.com/ru/post/169381/


Integration testing

https://www.youtube.com/watch?v=Lnc3o8cCwZY

Code Coverage (CC) - https://www.youtube.com/watch?v=QDFI19lj4OM
Это инструмент, позволяющий выяснить, какой процент кода покрыт тестами.
Чтобы запустить программу в этом режиме нужно нажать на значок щита рядом с кнопкой Run.
Coverage высчитывается для текущей выбранной конфигурации запуска.

MapStruct

https://mapstruct.org/documentation/dev/reference/html/
https://rukovodstvo.net/posts/id_799/?ysclid=l65537vpfb153611880
Mapstruct — это библиотека, которая помогает сопоставлять (маппить) объекты одних сущностей
в объекты других сущностей при помощи сгенерированного кода на основе конфигураций,
которые описываются через интерфейсы.


Global Exception handler

https://habr.com/ru/post/528116/
https://www.baeldung.com/exception-handling-for-rest-with-spring#controlleradvice
Любой класс с аннотацией @ControllerAdvice является глобальным обработчиком исключений,
который очень гибко настраивается. Метод handleException имеет аннотацию @ExceptionHandler,
в которой, можно определить список обрабатываемых исключений.


Properties

Как установить свои проперти?
Открываете файл application.properties, изучаете. В IntelliJ IDEA, чуть правее середины,
в верхнем интерфейсе(около кнопки Run) есть выпадающее окно, далее жмете Edit configurations.
Нажмите на плюсик слева и добавьте свою конфигурацию, например с названием RunDataInitializer.
Далее выбираете Modify options(подсвечено), ставите галочку на строке Override configuratin properties,
вводите свои переменные в режиме ключ-значение, в Build and run укажите класс с методом main и сохраняете
свою новую конфигурацию.
По этой же схеме нужно будет переписать конфигурация MisApplication.
И проверьте аннотацию @СonditionalOnExpression, класс DataInitializer запустится тогда,
когда в будет выбрана нужная конфигурация, с нужной переменной "RUN_INIT".


ApiValidationUtils

Используйте данный класс для валидации данных в контроллере.
https://struchkov.dev/blog/spring-boot-validation/

FlyWay
Flyway - это инструмент миграции (переноса) базы данных. Проще говоря, это инструмент,
который помогает вам выполнять сценарии базы данных при развертывании приложений.
Flyway поддерживает два типа сценариев, SQL и Java. Вы можете упаковать сценарий в приложение.
Когда приложение запускается, Flyway управляет выполнением этих сценариев.
Эти сценарии называются миграцией Flyway.
Flyway создаст таблицу в вашей БД для записи выполнения миграции.
Имя таблицы по умолчанию:flyway_schema_history. В данном проекте все сценарии хранятся в ресурсах > db.migrations.
Основная информации по ссылкам по порядку вполне достаточно для освоения:

https://www.youtube.com/watch?v=ArM7nCys4hY
https://www.youtube.com/watch?v=61ChGaqxELw


JpaRepository

Для простых CRUD запросов используйте готовые методы  JpaRepository.
Для более сложных запросов можно использовать анотацию @query над методом и
там прописать SQL запрос.
https://sysout.ru/spring-data-jpa-zaprosy-generiruemye-po-imeni-metoda/
https://habr.com/ru/post/435114/


SQL Учебник

https://www.schoolsw3.com/sql/index.php


Mockito

https://habr.com/ru/post/444982/
https://www.youtube.com/watch?v=Wmrdfzzpr6A
https://www.youtube.com/watch?v=lpPEAHLGoJg



**DTO** (_Data Transfer Object_) https://habr.com/ru/post/513072/ 
шаблон проектирования, используемый для передачи данных между подсистемами приложения. 
DTO объект является упрощенным представлением Entity. DTO - это не сущность! При запросе сущности из бд вместо Entity отправляем на фронт её DTO. 
На каждую сущность создается свой бин-конвертер в DTO, чтобы его можно было вызывать из любой точки программы. Конвертацию можно делать через mapstract.

DTO имеет ряд преимуществ перед Entity:
1) Инкапсулирует поля Entity, которые мы бы не хотели показывать при передаче DTO куда-либо.
2) Entity внутри себя может хранить ссылки на объекты. Если будем передавать ее на фронт, то эти объекты будут подтягиваться из бд. 
   Если такие объекты еще и ссылаются друг на друга, мы можем получить StackOverFlow.
3) DTO не должен содержать какую-либо бизнес-логику
4) Можно сгруппировать несколько сущностей в одну DTO, если фронт это устраивает.



Spring security с авторизацией токеном jsonwebtoken
https://www.bezkoder.com/spring-boot-jwt-authentication/

Используемые классы:
WebSecurityConfigurerAdapter - основной класс конфгурации. В массиве AUTH_WHITELIST можно добавить открытые
ресурсы. В методе configure(HttpSecurity http) настраивается
UserDetailsServiceImpl - содержит метод поиска и загрузки пользователя по email и создание на его основе
объекта UserDetails который будет использоваться для аутентификации и проверки
UsernamePasswordAuthenticationToken получает

LocalDateTime
Дата и время должны быть в формате dd.MM.yyyy HH:mm".

Связи между сущностями.

@OneToOne
Эта связь используется, когда например у каждого гражданина может быть один паспорт, а у паспорта один гражданин.
Эту связь можно сделать однонаправленной и двунапрвленной. 
Однонаправленная связь:
В однонаправленной связи только одна сущность имеет поле или свойство связи, которое ссылается на другую.
Связанное поле объявлено с помощью аннотации @JoinColumn, параметр name которой обозначает 
поле в БД для создания связи.
В однонаправленных отношениях одна из сторон (и только одна) должна быть владельцем и 
нести ответственность за обновление связанных полей. Т.е если удаляется user из базы, то сначала JPA самостоятельно
определяет наличие паспорта, удаляется сначала его и только потом самого юзера.
Двунаправленная связь:
В двунаправленной связи каждый объект имеет поле или свойство отношения, которое ссылается на другой объект.
Обратная сторона двунаправленного отношения должна ссылаться на свою сторону-владельца с помощью элемента mappedBy.
Элемент mappedBy обозначает свойство или поле в сущности, которая является владельцем отношения.
Использование общего первичного ключа с @MapsId
Это означает что источник и цель имеют одни и те же значения первичного ключа.
В таблице это выглядит так, убирается колонка с pk и остается колонка с fk другой таблицы.

@ManyToOne
Это когда на один обьект( столбец или набор столбцов) ссылается на другой обьект, которые содержат уникальные значения.
Сторона-владелец этих отношений обычно находится в @ManyToOne и mappedBy в родительском объекте
Так же эта связь может быть однонаправленная и двунаправленная.
В таблице это выглядит так : в таблице , которая считается владельцем, находится FK второй таблицы.

@OneToMany
В этом отношении каждая строка одного обьекта ссылается на множество записей в другом обьекте.
Но если связь будет однонаправленная, то создаться третья таблица, где будут
хранится FK двух таблиц, как при связи @ManyToMany.

@ManyToMany
При этой связи создается третья таблица(Join Table), где мы можем увидеть связь между 
строками двух других таблиц.
Столбцы Join Table- это FK , которые ссылаютя на PK связываемых таблиц.

Типы загрузки коллекций в базу:
- fetch = FetchType.LAZY - не загружает отношения, если вы не вызываете его с помощью метода getter.
- fetch = FetchType.EAGER - загружаются все отношения.
Плюсы и минусы:
- Lazy initialization повышает производительность, избегая ненужных вычислений и уменьшая требования к памяти.
- Eager initialization потребляет больше памяти, а скорость обработки медленная.

https://java-online.ru/hibernate-entities.xhtml
https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-jpa/jpa-otnosheniia-sushchnostei


Lombok - https://projectlombok.org/features/
Существенно сокращает код благодаря собственным аннотациям. 
Позволяет не писать геттеры, сеттеры, конструкторы, Equals, toString и т.д. 
В аннотированном классе все необходимые методы будут сгенерированы во время компиляции.

@Getter/@Setter сгенерирует геттеры и сеттеры для всех полей класса.
@NoArgsConstructor - создаст конструктор без параметров.
@RequiredArgsConstructor – создаст конструктор только для final полей.
@AllArgsConstructor – создаст конструктор для всех полей.
@builder создаст билдер вместо конструктора (согласно шаблону builder)

MockMvc - позволяет проводить интеграционное тестирование API имитируя запросы к приложению. 
Избавляет от написания отдельного RestTemplate-приложения
https://www.baeldung.com/integration-testing-in-spring








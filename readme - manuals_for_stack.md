MIS

Этот раздел для описания и концентрации знаний по всем технологиям, используемым на проекте.
Если вы столкнулись с проблемой и нашли решение, поделитесь кратко технологией и хорошими ресурсами.
Не стесняйтесь делиться информацией и делайте добро.

ВАЖНО!
Если вы модифицировали логику или привнесли функционал,
или нашли дополнительные полезные ресурсы, то
обязательно допишите здесь полезную информацию для всех.

**_**

**_РАЗНОЕ_**

**Properties** - Позволяют менять настройки запуска приложения. Эти настройки хранятся только на вашем пк. Например, логин/пароль от бд
Как установить свои проперти?
Открываете файл application.properties, изучаете. В IntelliJ IDEA, чуть правее середины,
в верхнем интерфейсе(около кнопки Run) есть выпадающее окно, далее жмете Edit configurations.
Нажмите на плюсик слева и добавьте свою конфигурацию, например с названием RunDataInitializer.
Далее выбираете Modify options(подсвечено), ставите галочку на строке Override configuratin properties,
вводите свои переменные в режиме ключ-значение, в Build and run укажите класс с методом main и сохраняете
свою новую конфигурацию.
По этой же схеме нужно будет переписать конфигурацию MisApplication.
И проверьте аннотацию @СonditionalOnExpression, класс DataInitializer запустится тогда,
когда в ней будет выбрана нужная конфигурация, с нужной переменной "RUN_INIT".

**Lombok** - Существенно сокращает код благодаря собственным аннотациям.
Позволяет не писать геттеры, сеттеры, конструкторы, Equals, toString и т.д.
В аннотированном классе все необходимые методы будут сгенерированы во время компиляции.
https://projectlombok.org/features/

- @Getter/@Setter сгенерирует геттеры и сеттеры для всех полей класса.
- @NoArgsConstructor - создаст конструктор без параметров.
- @RequiredArgsConstructor – создаст конструктор только для final полей.
- @AllArgsConstructor – создаст конструктор для всех полей.
- @builder создаст билдер вместо конструктора (согласно шаблону builder)

**Global Exception handler** - Любой класс с аннотацией @ControllerAdvice является глобальным обработчиком исключений,
который очень гибко настраивается. Метод handleException имеет аннотацию @ExceptionHandler,
в которой, можно определить список обрабатываемых исключений.
https://habr.com/ru/post/528116/
https://www.baeldung.com/exception-handling-for-rest-with-spring#controlleradvice

**LocalDateTime** - Дата и время должны быть в формате dd.MM.yyyy HH:mm".

**_**

**_ТЕСТИРОВАНИЕ_**

**Unit testing** - https://habr.com/ru/post/169381/

**Integration testing** -  https://www.youtube.com/watch?v=Lnc3o8cCwZY

**Code Coverage** (_CC_) - Это инструмент, позволяющий выяснить, какой процент кода покрыт тестами.
Чтобы запустить программу в этом режиме нужно нажать на значок щита рядом с кнопкой Run.
Coverage высчитывается для текущей выбранной конфигурации запуска.
https://www.youtube.com/watch?v=QDFI19lj4OM

**MockMvc** - позволяет проводить интеграционное тестирование API имитируя запросы к приложению.
Избавляет от написания отдельного RestTemplate-приложения
https://www.baeldung.com/integration-testing-in-spring

**Mockito** - 
https://habr.com/ru/post/444982/
https://www.youtube.com/watch?v=Wmrdfzzpr6A
https://www.youtube.com/watch?v=lpPEAHLGoJg

**_**

**РАБОТА С СУЩНОСТЯМИ**

**DTO** (_Data Transfer Object_) https://habr.com/ru/post/513072/
шаблон проектирования, используемый для передачи данных между подсистемами приложения.
DTO объект является упрощенным представлением Entity. DTO - это не сущность! При запросе сущности из бд вместо Entity отправляем на фронт её DTO.
На каждую сущность создается свой бин-конвертер в DTO, чтобы его можно было вызывать из любой точки программы. Конвертацию можно делать через mapstract.

DTO имеет ряд преимуществ перед Entity:
1) Инкапсулирует поля Entity, которые мы бы не хотели показывать при передаче DTO куда-либо.
2) Entity внутри себя может хранить ссылки на объекты. Если будем передавать ее на фронт, то эти объекты будут подтягиваться из бд.
   Если такие объекты еще и ссылаются друг на друга, мы можем получить StackOverFlow.
3) DTO не должен содержать какую-либо бизнес-логику
4) Можно сгруппировать несколько сущностей в одну DTO, если фронт это устраивает.

**MapStruct** - это библиотека, которая помогает сопоставлять (маппить) объекты одних сущностей
в объекты других сущностей при помощи сгенерированного кода на основе конфигураций,
которые описываются через интерфейсы.
https://mapstruct.org/documentation/dev/reference/html/
https://rukovodstvo.net/posts/id_799/?ysclid=l65537vpfb153611880

**Связи между сущностями**
- _@OneToOne_ - Эта связь используется, когда например у каждого гражданина может быть один паспорт, а у паспорта один гражданин.
  Эту связь можно сделать однонаправленной и двунапрвленной.
  Однонаправленная связь:
  В однонаправленной связи только одна сущность имеет поле или свойство связи, которое ссылается на другую.
  Связанное поле объявлено с помощью аннотации @JoinColumn, параметр name которой обозначает
  поле в БД для создания связи.
  В однонаправленных отношениях одна из сторон (и только одна) должна быть владельцем и
  нести ответственность за обновление связанных полей. Т.е если удаляется user из базы, то сначала JPA самостоятельно
  определяет наличие паспорта, удаляется сначала его и только потом самого юзера.
  Двунаправленная связь:
  В двунаправленной связи каждый объект имеет поле или свойство отношения, которое ссылается на другой объект.
  Обратная сторона двунаправленного отношения должна ссылаться на свою сторону-владельца с помощью элемента mappedBy.
  Элемент mappedBy обозначает свойство или поле в сущности, которая является владельцем отношения.
  Использование общего первичного ключа с @MapsId
  Это означает что источник и цель имеют одни и те же значения первичного ключа.
  В таблице это выглядит так, убирается колонка с pk и остается колонка с fk другой таблицы.

- _@ManyToOne_ - Это когда на один обьект( столбец или набор столбцов) ссылается на другой обьект, которые содержат уникальные значения.
  Сторона-владелец этих отношений обычно находится в @ManyToOne и mappedBy в родительском объекте
  Так же эта связь может быть однонаправленная и двунаправленная.
  В таблице это выглядит так : в таблице , которая считается владельцем, находится FK второй таблицы.

- _@OneToMany_ - В этом отношении каждая строка одного обьекта ссылается на множество записей в другом обьекте.
  Но если связь будет однонаправленная, то создаться третья таблица, где будут
  хранится FK двух таблиц, как при связи @ManyToMany.

- _@ManyToMany_ - При этой связи создается третья таблица(Join Table), где мы можем увидеть связь между
  строками двух других таблиц.
  Столбцы Join Table- это FK , которые ссылаютя на PK связываемых таблиц.

**_**

**_РАБОТА С БД_**

**HQL** - https://java-online.ru/hibernate-hql.xhtml
**SQL Учебник** - https://www.schoolsw3.com/sql/index.php

**JpaRepository** - Для простых CRUD запросов используйте готовые методы JpaRepository.
Для более сложных запросов можно использовать аннотацию @query над методом и
там прописать SQL запрос.
https://sysout.ru/spring-data-jpa-zaprosy-generiruemye-po-imeni-metoda/
https://habr.com/ru/post/435114/

**Flyway** - это инструмент миграции (переноса) базы данных. Проще говоря, это инструмент,
который помогает вам выполнять сценарии базы данных при развертывании приложений.
Flyway поддерживает два типа сценариев, SQL и Java. Вы можете упаковать сценарий в приложение.
Когда приложение запускается, Flyway управляет выполнением этих сценариев.
Эти сценарии называются миграцией Flyway.
Flyway создаст таблицу в вашей БД для записи выполнения миграции.
Имя таблицы по умолчанию:flyway_schema_history. В данном проекте все сценарии хранятся в ресурсах > db.migrations.
Основная информации по ссылкам по порядку вполне достаточно для освоения:
https://www.youtube.com/watch?v=ArM7nCys4hY
https://www.youtube.com/watch?v=61ChGaqxELw

**Типы загрузки коллекций в базу:**
- fetch = FetchType.LAZY - не загружает отношения, если вы не вызываете его с помощью метода getter.
- fetch = FetchType.EAGER - загружаются все отношения.
  Плюсы и минусы:
- Lazy initialization повышает производительность, избегая ненужных вычислений и уменьшая требования к памяти.
- Eager initialization потребляет больше памяти, а скорость обработки медленная.
  https://java-online.ru/hibernate-entities.xhtml
  https://coderlessons.com/tutorials/java-tekhnologii/vyuchit-jpa/jpa-otnosheniia-sushchnostei

**_**

**_РАБОТА С КОНТРОЛЛЕРАМИ_**

**Swagger** - Это фреймворк для спецификации RESTful API. С его помощью можно удобно отправлять запросы на сервер.
Web интерфейс Swagger доступен после старта проекта и аутентификации под определенным юзером
по адресу: http://localhost:8080/swagger-ui/index.html#/ (значение порта 8080 может быть настроено в
application.properties: server.port=)
Информация по SWAGGER - https://habr.com/ru/post/434798/
Настройка в классе SwaggerConfig.
Кратко по работе со Swagger:
После запуска проекта перейдя по адресу: http://localhost:8080/swagger-ui/index.html загрузится
веб интерфейс Swagger. Нам будет доступен контроллер для аутентификации auth-controller
с помощью которого мы можем отправить запрос типа LoginRequest, содержащий два строковых поля:
email и password на сервер (нажать try it out -> вместо string подставить значения -> execute).
При успешной аутентификации получаем ответ типа JwtResponse содержащий сгенерированный токен
(начинается на Bearer), id, email, roles. Для его добавления в header при каждом последующем
запросе нужно скопировать его значение без кавычек, нажать Authorize (кнопка с замочком) ->
вставить значение в поле value -> Authorize (замочек поменяет значение на закрытый).
Для тестирования работы методов контроллера выбираем нужный -> try it out -> вводим необходимые
данные -> execute.

**ApiValidationUtils** - Используйте данный класс для валидации данных в контроллере.
https://struchkov.dev/blog/spring-boot-validation/
  
**Spring security** с авторизацией токеном **jsonwebtoken**
https://www.bezkoder.com/spring-boot-jwt-authentication/

Используемые классы:
- WebSecurityConfigurerAdapter - основной класс конфигурации. В массиве AUTH_WHITELIST можно добавить открытые
ресурсы. В методе configure(HttpSecurity http) настраивается
- UserDetailsServiceImpl - содержит метод поиска и загрузки пользователя по email и создание на его основе
объекта UserDetails который будет использоваться для аутентификации и проверки
UsernamePasswordAuthenticationToken получает








